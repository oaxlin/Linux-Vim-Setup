#!/usr/bin/perl
use strict;
use warnings;

my $nb_errors = 0;

# run checks on each file
my $files = {
    'Git::Hooks::PerlCritic'  => [],
    # other file types can be expanded/checked if needed
};

my $git_root = `git rev-parse --show-toplevel`;
chomp $git_root;
exit 1 if (!$git_root);
if (-e "$git_root/.git-perl5lib") {
    my $tmp = `cat $git_root/.git-perl5lib`;
    chop($tmp);
    $ENV{'PERL5LIB'} = $tmp =~ s/\$PERL5LIB// ? ($ENV{'PERL5LIB'}//'').$tmp : $tmp;
} else {
    $ENV{'PERL5LIB'} ||= "$git_root/lib";
}

if (qx{ls ~/.git-templates/hooks/pre-commit}) {
    # running the user file would potentially be a security risk.  so instead let's just take a peek to make sure they are the same
    qx{which md5 2>&1 > /dev/null};
    my $prog = $? ? 'md5sum' : 'md5 -r'; # linux vs mac
    my ($me) = qx{$prog $0} =~ /^([^ ]+)/;
    my ($you) = qx{$prog ~/.git-templates/hooks/pre-commit} =~ /^([^ ]+)/;
    if ($you ne $me) {
        print "###############################################################\n";
        print "##\n";
        print "##   WARNING: Your pre-commit hook appears to be out of date\n";
        print "##\n";
        print "###############################################################\n";
        $nb_errors++
    }
}

my @extra_files; # simple way to allow usage via command line
{
    use File::Find;
    no warnings 'File::Find';
    my $git_root_quoted = quotemeta $git_root;
    find({
            follow_fast => 1,
            wanted => sub {
                my $f = $_;
                return if $File::Find::fullname =~ /^$git_root_quoted\/\.git(\/.*)?$/; # avoid .git directory
                push @extra_files, $File::Find::name if ! -d $f
            },
    }, @ARGV);
}

use List::MoreUtils qw(uniq);
my @allfiles = uniq sort `git diff --cached --name-only`,@extra_files;
chomp @allfiles;
for my $filepath ( @allfiles ) {
    # we pre-lookup so that tools that accept a list of files can do so for better performance
    my $use_cnt = 0;
    foreach my $package ('Git::Hooks::Compile::Perl','Git::Hooks::PerlCritic','Git::Hooks::Compile::Bash','Git::Hooks::Compile::Sh') {
        if (eval{$package->will_check($filepath)}) { # could fit into more than one of these
            push @{$files->{$package}}, $filepath;
            $use_cnt++;
        } elsif ($@) {
            warn $@;
            $nb_errors++;
        }
    }
    if (!-e $filepath) {
        print "pre-commit: file not found: $filepath\n";
        $nb_errors++;
    } elsif (!$use_cnt) {
        print "pre-commit: unknown file type: $filepath\n";
        $nb_errors++;
    }
}

foreach my $package ( sort keys %$files ) {
    next unless scalar @{$files->{$package}};
    $nb_errors++ if !eval{$package->check(@{$files->{$package}})};
}

if ( $nb_errors ) {
    print "pre-commit: Aborting commit due to pre-commit hook failure.  You can still commit with the --no-verify argument.\n";
    exit 1;
}
exit 0;

package Git::Hooks::Compile::ShellCommon;
    use File::Basename;

    sub will_check {
        my $self = shift;
        my $shell = shift || die 'Shell name that supports -n required (sh / bash)';
        my $filepath = shift;
        my $fh;
        my $head = '';
        if (-e $filepath && !-d $filepath && eval{open $fh, '-|', '/usr/bin/head', ('-n',1,'--',$filepath)}) {
            $head = <$fh>;
            close $fh;
        }
        my @file_infos = fileparse( $filepath, qr/\.[^.]*/ );
        my $shell_quoted = quotemeta $shell;
        if ( $head =~ /^\#\!.*[\/\ ]$shell_quoted$/ ) {
            return 1;
        }
        return 0;
    }

    sub check {
        my $self = shift;
        my $shell = shift || die 'Shell name that supports -n required (sh / bash)';
        my $errors = 0;
        if (my $num = scalar @_) {
            print "Checking $shell -n ($num files)\n";
            foreach my $file (@_) {
                my $out = qx{$shell -n -- $file 2>&1};
                if ($?) {
                    print $out;
                    $errors++;
                }
            }
        }
        return !$errors;
    }

1;

package Git::Hooks::Compile::Bash;
  require Git::Hooks::Compile::ShellCommon;
  sub will_check { shift; Git::Hooks::Compile::ShellCommon->will_check('bash',@_); }
  sub check { shift; Git::Hooks::Compile::ShellCommon->check('bash',@_); }

1;

package Git::Hooks::Compile::Sh;
  require Git::Hooks::Compile::ShellCommon;
  sub will_check { shift; Git::Hooks::Compile::ShellCommon->will_check('bash',@_); }
  sub check { shift; Git::Hooks::Compile::ShellCommon->check('bash',@_); }

1;

package Git::Hooks::Compile::Perl;
    use File::Basename;

    sub will_check {
        my $self = shift;
        my $filepath = shift;
        my $fh;
        my $head = '';
        if (-e $filepath && !-d $filepath && eval{open $fh, '-|', '/usr/bin/head', ('-n',1,'--',$filepath)}) {
            $head = <$fh>;
            close $fh;
        }
        my @file_infos = fileparse( $filepath, qr/\.[^.]*/ );
        if ( $file_infos[2] =~ /^\.(pl|cgi|pm)$/ || $head =~ /^(package [^;]+;|\#\!.*[\/\ ]perl)$/ ) {
            return 1;
        }
        return 0;
    }

    sub check {
        my $self = shift;
        my $errors = 0;
        if (my $num = scalar @_) {
            print "Checking perl -c ($num files)\n";
            foreach my $file (@_) {
                my $out = qx{perl -c -- $file 2>&1};
                if ($?) {
                    print $out;
                    $errors++;
                }
            }
        }
        return !$errors;
    }

1;

package Git::Hooks::PerlCritic;
    require Git::Hooks::Compile::Perl;

    sub will_check { my $self = shift; Git::Hooks::Compile::Perl->will_check(@_); }

    sub check {
        my $self = shift;
        my $errors = 0;
        if (my $num = scalar @_) {
            # perlcritic checks on something that failes "perl -c" is kinda pointless
            print "Checking perlcritic ($num files)\n";
            my $out = qx{perlcritic --quiet -- @_};
            if ($?) {
                print $out;
                $errors++;
            }
        }
        return !$errors;
    }

1;
